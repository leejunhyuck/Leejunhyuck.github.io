---  
layout: post  
title: "[Review] 자바 ORM 표준 JPA 프로그래밍 책 정리"  
subtitle: "자바 ORM 표준 JPA 프로그래밍 책 정리"  
categories: review
tags: review book jpa
comments: true
header-img: img/review/jpa-orm-programming.png

---
> `자바 ORM 표준 JPA 프로그래밍` 책을 보고 정리한 글입니다.

## JPA 관련하여 관심있게 본 내용을 정리

데이터베이스는 기본 키의 값으로 각 로우를 구분한다. 반면에 객체는 동일성비교와 동등성 비교라는 두 가지 비교 방법이 있다.

* 동일성 비교는 == 비교다. 객체 인스턴스의 주소 값을 비교한다.
* 동등성 비교는 equals() 메소드를 사용해서 객체 내부의 값을 비교한다.

엔티티 매니저

    엔티티 매니저 팩토리 -> 애플리케이션 전체에서 딱 한 번만 생성하고 공유해서 사용해야 한다.
                    -> 여러 스레드가 동시에 접근해도 안전하므로 서로 다른 스레드 간에 공유해도 된다.

    엔티티 매니저      -> 엔티티 매니저를 사용해서 엔티티를 데이터베이스에 등록/수정/삭제/조회 할수 있다.
                    -> 데이터베이스 커넥션과 밀접한 관계가 있으므로 스레드간에 공유하거나 재사용하면 안 된다.
                    -> 여러 스레드가 동시에 접근하면 동시성 문제가 발생하므로 스레드 간에 절대 공유하면 안 된다.
                    -> 영속성 컨텍스트는 엔티티 매니저를 생성할 때 하나 만들어진다.

엔티티의 생명주기
* 비영속 : 영속성 컨텍스트와 전혀 관계가 없는 상태
* 영속 : 영속성 컨텍스트에 저장된 상태
* 준영속 : 영속성 컨텍스트에 저장되었다가 분리된 상태
* 삭제 : 삭제된 상태


영속성 컨텍스트의 특징
* 영속성 컨텍스트와 식별자 값
    - 영속 상태는 식별자 값이 반드시 있어야 한다.
    - 식별자 값이 없으면 예외가 발생한다.

* 영속성 컨텍스트와 데이터베이스 저장
    - 영속성 컨텍스트에 새로 저장된 엔티티를 데이터베이스에 반영하는데 이것을 플러시라 한다.

* 영속성 컨텍스트의 장점
    - 1차 캐시
        - 1차캐시의 기본 키는 식별자 값이다 (데이터베이스의 키), 영속된 엔티티의 동일성 보장
    - 동일성 보장
    - 트랜잭션을 지원하는 쓰기 지연
        - 쓰기지연 sql을 반영한다. flush -> 영속성 컨텍스트에 있는 내용을 데이터베이스와 동기화하고 트랜잭션을 커밋한다.
    - 변경 감지
        - 트랜잭션을 커밋하면 엔티티 매니저 내부에서 먼저 플러시가 호출된다.  
          엔티티와 스냅샷을 비교해서 변경된 엔티티를 찾는다.  
          변경된 엔티티가 있으면 수정 쿼리를 생성해서 쓰기 지연 sql 저장소에 보낸다.  
          쓰기지연 엔티티가 있으면 수정 쿼리를 생성해서 쓰기 지연 sql 저장소에 보낸다.  
          쓰기 지연 저장소의 SQL을 데이터베이스에 보낸다.  
          데이터베이스 트랜잭션을 커밋한다.

* 플러시(flush)
    * 영속성 컨텍스트의 변경 내용을 데이터베이스에 반영한다.
        1. 변경감지가 동작해서 영속성 컨텍스트에 있는 모든 엔티티를 스냅샷과 비교해서 수정된 엔티티를 찾난다. 수정된 엔티티는 수정 쿼리를 만들어 쓰기 지연 SQL 저장소에 등록한다.
        2. 쓰기 지연 sql 저장소의 쿼리를 데이터베이스에 전송한다.


* 식별자
    1. 자연키 ( 비즈니스에 의미 있는 키)
    2. 대리키 (AUTO_INCREMENT ..)


* 권장하는 식별자 선택 전략
    1. null값은 허용하지 않는다.
    2. 유일해야 한다.
    3. 변해선 안된다.


* 외래키를 어디에 둘 것인가?
    - 주 테이블에 외래 키  
      외래 키를 객체 참조와 비슷하게 사용할 수 있어서 객체지향 개발자들이 선호한다.
      이 방법의 장점은 주 테이블이 외래 키를 가지고 있으므로 주 테이블만 확인해도 대상 테이블과 연관관계가 있는지 알 수 있다.

    - 대상 테이블에 외래 키  
      테이블 관계를 일대일에서 일대다로 변경할 때 테이블 구조를 그대로 유지할 수 있다.

        - 식별관계 -> 받아온 식별자를 기본 키 + 외래 키로 사용한다.
        - 비식별관계 -> 받아온 식별자는 외래 키로만 사용하고 새로운 식별자를 추가한다.


* DynamicUpdate
    * 모든 필드를 업데이트를 사용하면 수정쿼리가 항상 같다. 따라서 애플리케이션 로딩 시점에 수정쿼리를 미리 생성 해 두고, 재사용할 수 있다.
    * 데이터베이스에 동일한 쿼리를 보내면 데이터베이스는 이전에 한번 파싱된 쿼리를 재사용할 수 있다.
    * 데이터베이스에 보내는 데이터 전송량이 증가하는 단점이 있다.
    * 30개 이상일 경우 이점이 있다. (하지만 30개 이상일 경우는 설계가 잘못 되어있을 가능성이 크다.)



---